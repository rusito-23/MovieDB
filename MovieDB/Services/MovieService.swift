//
//  MoviesWorker.swift
//  MovieDB
//
//  Created by Igor Andruskiewitsch on 18/02/2019.
//  Copyright (c) 2019 Igor Andruskiewitsch. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import Foundation
import UIKit
import Alamofire

protocol MovieService {
  func findAll(completion: @escaping (Movies.Response?) -> Void)
  func fetchPoster(for url: String?, completion: @escaping (UIImage?) -> Void)
  func fetchBackDrop(for url: String?, completion: @escaping (UIImage?) -> Void)
}

class MovieServiceImpl: MovieService {

  // MARK: variables
  // discover
  private let endPoint = "https://api.themoviedb.org/3/"
  private let filterStarter = "/movie?"
  private let apiKey = "api_key=***REMOVED***"
  
  // poster
  private let posterEndPoint = "https://image.tmdb.org/t/p/original"
  
  // video
  private let videoFilter = "/videos?"
  private let videoMovieFilter = "movie/"
  
  // general
  private let urlSession = URLSession(configuration: .default)
  private let queue = DispatchQueue(label: "alamofire.background", qos: .background, attributes: .concurrent)

  enum Action: String {
    case discover
    case poster
    case trailer
  }
  
  // MARK: private util methods
  
  private func createUrl(for action: Action, with path: String?) -> URL? {
    switch action {
    case .discover:
      return URL(string: endPoint + action.rawValue + filterStarter + apiKey)
    case .poster:
      guard let `path` = path else {
        return nil
      }
      return URL(string: posterEndPoint + path)
    case .trailer:
      guard let id = path else { return nil }
      return URL(string: endPoint + videoMovieFilter + id + videoFilter + apiKey)
    }
  }
  
  // MARK: public methods
  
  func findAll(completion: @escaping (Movies.Response?) -> Void) {
    guard let url = self.createUrl(for: .discover, with: nil) else {
      completion(nil)
      return
    }
    
    Alamofire.request(url,
                      method: .get,
                      parameters: ["include_docs": "true"])
      .validate()
      .responseJSON(queue: queue) { response in
        guard response.result.isSuccess else {
          completion(nil)
          return
        }
        
        guard let value = response.result.value as? [String: Any],
          let movies = value["results"] as? [[String: Any]] else {
            logger.error("Malformed data received from findAllMovies service")
            completion(nil)
            return
        }
        
        let result = Movies.Response(json: movies)
        self.fetchTrailerUrl(for: result, completion: completion)
    }
  }
  
  private func fetchTrailerUrl(for res: Movies.Response?, completion: @escaping (Movies.Response?) -> Void) {
    logger.verbose("Starting trailer fetch")
    
    let group = DispatchGroup()
    
    guard let `res` = res else { completion(nil); return}
    
    for movie in res.movies {
      guard let url = self.createUrl(for: .trailer, with: String(movie.id)) else { break }
      
      group.enter()
      
      Alamofire.request(url,
                        method: .get,
                        parameters: ["include_docs": "true"])
      .validate()
      .responseJSON(queue: queue) { response in // weak self?

        guard response.result.isSuccess else {
          logger.error("Trailer request failed!")
          group.leave()
          return
        }

        guard let value = response.result.value as? [String: Any],
              let videos = value["results"] as? [[String: Any]] else {
            logger.error("Malformed data received from fetchTrailerUrl service")
            group.leave()
            return
        }
        
        for v in videos {
          if v["type"] as? String == "Trailer" && v["site"] as? String == "YouTube" {
            // we take the first trailer we find
            movie.trailerUrl = v["key"] as? String
            break;
          }
        }
        
        group.leave()
      }
    }

    group.wait()
    logger.verbose("Fetched all trailers")
    completion(res)
  }
  
  // fetches the backDrop for a specific movie
  func fetchBackDrop(for url: String?, completion: @escaping (UIImage?) -> Void) {
    guard let url = createUrl(for: .poster, with: url) else {
      completion(nil)
      return
    }
    fetchImage(with: url, completion: completion)
  }

  // fetches poster for a movie, returns the request so we can cancel it
  func fetchPoster(for url: String?, completion: @escaping (UIImage?) -> Void) {
    guard let url = createUrl(for: .poster, with: url) else {
      completion(nil)
      return
    }
    fetchImage(with: url, completion: completion)
  }
    
  private func fetchImage(with url: URL, completion: @escaping (UIImage?) -> Void) {
    Alamofire.request(url, method: .get)
      .validate()
      .responseData(queue: queue, completionHandler: { (responseData) in
        guard let image = UIImage(data: responseData.data!) else {
          completion(nil)
          return
        }
        completion(image)
      })
  }
  
}
